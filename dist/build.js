(function(){"use strict";const logger={log:e=>{console.log(`%cCumcord%c ${e}`,"background-color: #7289da; color: white; border-radius: 4px; padding: 0px 6px 0px 6px; font-weight: bold","")}};function getModules(){const e=window.webpackJsonp.push([[],{__extra_id__:(e,n,o)=>e.exports=o},[["__extra_id__"]]]);return delete e.m.__extra_id__,delete e.c.__extra_id__,e.c}function filterModules(e,n){let o=[];for(const t in e)if(e.hasOwnProperty(t)){const i=e[t].exports;i&&(i.default&&i.__esModule&&n(i.default)&&o.push(i.default),n(i)&&o.push(i))}return o}const webpackModules={modules:getModules(),find:e=>filterModules(webpackModules.modules,e)[0],findAll:e=>filterModules(webpackModules.modules,e),findByProps:(...e)=>webpackModules.find((n=>e.every((e=>void 0!==n[e])))),findByPropsAll:(...e)=>webpackModules.findAll((n=>e.every((e=>void 0!==n[e])))),findByPrototypes:(...e)=>webpackModules.find((n=>n.prototype&&e.every((e=>void 0!==n.prototype[e])))),findByDisplayName:e=>webpackModules.find((n=>n.displayName===e)),findByStringInPropsAll:(...e)=>webpackModules.findAll((n=>e.every((e=>1==Object.keys(n).some((n=>n.toLowerCase().includes(e.toLowerCase())))))))};webpackModules.find,webpackModules.findAll,webpackModules.findByProps,webpackModules.findByPropsAll,webpackModules.findByPrototypes,webpackModules.findByDisplayName,webpackModules.findByStringInPropsAll;const commonModules={constants:webpackModules.findByProps("API_HOST","APP_URL_PREFIX"),channels:webpackModules.findByProps("getChannelId","getVoiceChannelId"),Flux:webpackModules.findByProps("CachedStore","Store","connectStores"),FluxDispatcher:webpackModules.findByProps("_currentDispatchActionType","_subscriptions","_waitQueue"),i18n:webpackModules.findByProps("getLanguages","_requestedLocale","languages"),React:webpackModules.findByProps("__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","createElement"),ReactDOM:webpackModules.findByProps("__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","hydrate")};var getRandomValues;commonModules.React,commonModules.ReactDOM,commonModules.Flux,commonModules.FluxDispatcher,commonModules.constants,commonModules.channels,commonModules.i18n;var rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&!(getRandomValues="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}var REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(e){return"string"==typeof e&&REGEX.test(e)}for(var byteToHex=[],i=0;i<256;++i)byteToHex.push((i+256).toString(16).substr(1));function stringify(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=(byteToHex[e[n+0]]+byteToHex[e[n+1]]+byteToHex[e[n+2]]+byteToHex[e[n+3]]+"-"+byteToHex[e[n+4]]+byteToHex[e[n+5]]+"-"+byteToHex[e[n+6]]+byteToHex[e[n+7]]+"-"+byteToHex[e[n+8]]+byteToHex[e[n+9]]+"-"+byteToHex[e[n+10]]+byteToHex[e[n+11]]+byteToHex[e[n+12]]+byteToHex[e[n+13]]+byteToHex[e[n+14]]+byteToHex[e[n+15]]).toLowerCase();if(!validate(o))throw TypeError("Stringified UUID is invalid");return o}function v4(e,n,o){var t=(e=e||{}).random||(e.rng||rng)();if(t[6]=15&t[6]|64,t[8]=63&t[8]|128,n){o=o||0;for(var i=0;i<16;++i)n[o+i]=t[i];return n}return stringify(t)}let patches={};function hook(e,n){var o,t=!1;for(const i of patches[e].hooks)i.runInstead?(o=i.callback(n),t=!0):(t||(o=patches[e].originalFunction(...n),t=!0),i.callback(n,o));return o}function unpatch(e,n){const o=patches[e];var t=!1;if(o){const i=o.hooks;for(const e in i)i[e].id==n&&(o.functionParent[o.functionName]=o.originalFunction,delete i[e],t=!0);o.hooks[0]||delete patches[e]}return t}function unpatchAll(){logger.log("If you're a plugin developer and you ran this because you're curious as to what it does, I highly recommend you refresh your client because unfortunately everything that relies on the patcher has been unpatched.");for(const e in patches){const n=patches[e].hooks;for(const o in n)unpatch(e,n[o].id)}}const patcher={patch:(e,n,o,t=!1)=>{if("function"!=typeof n[e])throw new Error(`${e} is not a function in ${n.constructor.name}`);if(n.hasOwnProperty("CUMCORD_INJECTIONS")||(n.CUMCORD_INJECTIONS={}),!n.CUMCORD_INJECTIONS.hasOwnProperty(e)){const o=v4();n.CUMCORD_INJECTIONS[e]=o}const i=n.CUMCORD_INJECTIONS[e];if(!patches[i]){const o=Object.assign({},n)[e];patches[i]={originalFunction:o,functionParent:n,functionName:e,hooks:[]},n[e]=(...e)=>hook(i,e)}const r=v4();return patches[i].hooks.push({id:r,instead:t,callback:o}),()=>unpatch(i,r)},unpatchAll:unpatchAll,patches:patches};function promisifyRequest(e){return new Promise(((n,o)=>{e.oncomplete=e.onsuccess=()=>n(e.result),e.onabort=e.onerror=()=>o(e.error)}))}function createStore(e,n){const o=indexedDB.open(e);o.onupgradeneeded=()=>o.result.createObjectStore(n);const t=promisifyRequest(o);return(e,o)=>t.then((t=>o(t.transaction(n,e).objectStore(n))))}let defaultGetStoreFunc;function defaultGetStore(){return defaultGetStoreFunc||(defaultGetStoreFunc=createStore("keyval-store","keyval")),defaultGetStoreFunc}function get(e,n=defaultGetStore()){return n("readonly",(n=>promisifyRequest(n.get(e))))}function set(e,n,o=defaultGetStore()){return o("readwrite",(o=>(o.put(n,e),promisifyRequest(o.transaction))))}const noStore={cache:"no-store"},corsProxyUrl="https://cors.bridged.cc/";function loadPlugin(pluginId){const plugin=storage.getPlugin(pluginId);if(!plugin)throw new Error(`Plugin ${pluginId} not found`);if(window.cumcord.plugins.loadedPlugins[pluginId])throw new Error(`Plugin ${pluginId} already loaded`);const pluginObject=eval(plugin.js);window.cumcord.plugins.loadedPlugins[pluginId]=pluginObject,pluginObject.onLoad()}function unloadPlugin(e){if(!storage.getPlugin(e))throw new Error(`Plugin ${e} not found`);const n=window.cumcord.plugins.loadedPlugins[e];if(!n)throw new Error(`Plugin ${e} not loaded`);n.onUnload(),delete window.cumcord.plugins.loadedPlugins[e]}function enablePlugin(e){const n=storage.getPlugin(e);window.cumcord.plugins.loadedPlugins[e]&&unloadPlugin(e),loadPlugin(e),n.enabled||(n.enabled=!0,storage.setPlugin(e,n))}function disablePlugin(e){const n=storage.getPlugin(e);loaded&&unloadPlugin(e),n.enabled&&(n.enabled=!1,storage.setPlugin(e,n))}function togglePlugin(e){storage.getPlugin(e).enabled?disablePlugin(e):enablePlugin(e)}async function importPlugin(e){const n=e.replace(/\/?$/,"/"),o=new URL("plugin.json",n),t=new URL("plugin.js",n);let i=!0;const r=storage.getPlugin(n);let u,l,a,s=!1;try{u=await fetch(o,noStore)}catch{s=!0,u=await fetch(corsProxyUrl+o,noStore)}if(200!=u.status&&!r)throw new Error("Plugin manifest not returning success");try{l=await u.json()}catch{if(!r)throw new Error("Plugin manifest cannot be parsed")}if(r)if(i=r.enabled,l){if(r.manifest.hash==l.hash&&(r.manifest!=l&&(r.manifest=l,storage.setPlugin(n,r)),i))return void loadPlugin(n)}else if(i)return void loadPlugin(n);if(a=s?await await fetch(corsProxyUrl+t,noStore):await await fetch(t,noStore),200!=a.status)throw new Error("Plugin not returning success");const c=await a.text();return storage.setPlugin(n,{manifest:l,js:c,enabled:i}),i&&loadPlugin(n),!0}function removePlugin(e){unloadPlugin(e),delete window.cumcord.plugins.pluginCache[e],set("CumcordCache",window.cumcord.plugins.pluginCache)}var storage={initializePlugins:async()=>{let e=await get("CumcordCache");window.cumcord.plugins.loadedPlugins={},e?window.cumcord.plugins.pluginCache=e:(await set("CumcordCache",{}),window.cumcord.plugins.pluginCache={});for(let e of Object.keys(window.cumcord.plugins.pluginCache))importPlugin(e);window.cumcord.plugins.importPlugin=importPlugin,window.cumcord.plugins.removePlugin=removePlugin,window.cumcord.plugins.enablePlugin=enablePlugin,window.cumcord.plugins.disablePlugin=disablePlugin,window.cumcord.plugins.togglePlugin=togglePlugin},getPlugin:e=>window.cumcord.plugins.pluginCache[e],setPlugin:(e,n)=>{window.cumcord.plugins.pluginCache[e]=n,set("CumcordCache",window.cumcord.plugins.pluginCache)},removePlugin:removePlugin};function uninject(){for(let e of Object.keys(window.cumcord.plugins.pluginCache))try{unloadPlugin(e)}catch{}return patcher.unpatchAll(),delete window.cumcord,!0}async function initializeAPI(){logger.log("Initializing Cumcord API"),window.cumcord={uninject:uninject,modules:{webpackModules:webpackModules,common:commonModules},plugins:{},patcher:patcher},await storage.initializePlugins()}if(window.cumcord)throw new Error("Cumcord is already injected");initializeAPI()})();